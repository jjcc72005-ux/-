<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ù…Ø¨Ø¯Ù„ Ø§Ù„ØµÙˆØª</title>
<style>
body {
  font-family: sans-serif;
  background: #111;
  color: #fff;
  text-align: center;
  padding: 40px;
}
button, select {
  margin: 10px;
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 10px;
  border: none;
  cursor: pointer;
}
button:hover {
  background: #333;
}
audio {
  margin-top: 20px;
  width: 80%;
}
</style>
</head>
<body>
<h2>ğŸ™ï¸ Ù…Ø¨Ø¯Ù„ Ø§Ù„ØµÙˆØª Ø§Ù„Ø¨Ø³ÙŠØ·</h2>

<select id="effect">
  <option value="normal">ØµÙˆØª Ø¹Ø§Ø¯ÙŠ</option>
  <option value="female">ØµÙˆØª Ø¨Ù†Øª</option>
  <option value="old">ØµÙˆØª Ø±Ø¬Ù„ Ø¹Ø¬ÙˆØ²</option>
  <option value="robot">ØµÙˆØª Ø±ÙˆØ¨ÙˆØª</option>
  <option value="echo">ØµÙˆØª Ù…Ø¹ ØµØ¯Ù‰</option>
</select>

<br>

<button id="record">ğŸ¤ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„</button>
<button id="stop" disabled>â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù</button>
<audio id="player" controls></audio>

<script>
let mediaRecorder, audioChunks = [];

document.getElementById('record').onclick = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  mediaRecorder.start();
  audioChunks = [];
  mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
  mediaRecorder.onstop = () => processAudio(new Blob(audioChunks));
  document.getElementById('record').disabled = true;
  document.getElementById('stop').disabled = false;
};

document.getElementById('stop').onclick = () => {
  mediaRecorder.stop();
  document.getElementById('record').disabled = false;
  document.getElementById('stop').disabled = true;
};

function processAudio(blob) {
  const effect = document.getElementById('effect').value;
  const audioCtx = new AudioContext();
  const reader = new FileReader();
  reader.readAsArrayBuffer(blob);
  reader.onloadend = async () => {
    const buffer = await audioCtx.decodeAudioData(reader.result);
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;

    let output = source;
    let gainNode = audioCtx.createGain();
    let filter = audioCtx.createBiquadFilter();

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØµÙˆØª
    switch (effect) {
      case 'female':
        source.playbackRate.value = 1.5; // Ø£Ø³Ø±Ø¹ = Ø£Ù†Ø­Ù
        break;
      case 'old':
        source.playbackRate.value = 0.8; // Ø£Ø¨Ø·Ø£ = Ø£ØºÙ„Ø¸
        filter.type = "lowpass";
        filter.frequency.value = 1000;
        output.connect(filter);
        output = filter;
        break;
      case 'robot':
        const robotEffect = audioCtx.createWaveShaper();
        robotEffect.curve = new Float32Array(256).map((_, i) => Math.sin(i));
        output.connect(robotEffect);
        output = robotEffect;
        break;
      case 'echo':
        const delay = audioCtx.createDelay();
        delay.delayTime.value = 0.25;
        const feedback = audioCtx.createGain();
        feedback.gain.value = 0.4;
        delay.connect(feedback);
        feedback.connect(delay);
        output.connect(delay);
        output = delay;
        break;
      default:
        break;
    }

    output.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    source.start();

    // Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (ØªØ³Ø¬ÙŠÙ„ Ù…Ø¨Ø§Ø´Ø±)
    const dest = audioCtx.createMediaStreamDestination();
    output.connect(dest);
    const recorder = new MediaRecorder(dest.stream);
    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = e => {
      const outBlob = new Blob(chunks, { type: 'audio/webm' });
      document.getElementById('player').src = URL.createObjectURL(outBlob);
    };
    recorder.start();
    setTimeout(() => recorder.stop(), buffer.duration * 1000);
  };
}
</script>
</body>
</html>
